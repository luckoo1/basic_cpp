int Add(int a, int b)
{
    return a + b;
    //2.
    //a+b는 실행시간에 한다. 함수니깐
}

int main()
{
    int n1 = 1 + 2;
    //1.
    //이건 컴파일시점에 덧셈을 한다.
    //기계어 코드보면 3이라 되어 있다.
    int n2 = Add(1, 2);
}
//#######################################################################
//1.
//만약 사용자가 인자로 컴파일시간에 결정되는 상수를 보내면
//a+b는 컴파일 시간에 해달라
constexpr int Add(int a, int b)
{
    return a + b;
}

int main()
{
    int n1 = 1 + 2;

    int n2 = Add(1, 2);
    //2.
    //Add(1, 2) 코드는 컴파일 시간에 끝난다.
    int x[Add(1, 2)];
    //3.
    //배열 크기는 컴파일타임 상수가 들어가야한다.
    //보통이라면 안되겠지만 여기서는 된다.
    //constexpr을 사용해줬으니깐 가능
    //int Add(int a, int b)처럼 사용하면
    //에러가 뜬다.
}

/*
정리
1. 함수 인자로 컴파일 시간에 결정될 수 있는 상수값이 전달될 경우 컴파일 시간에 연산을 수행하는 함수

2. 함수 인자가 컴파일 시간에 결정되는 상수가 아닌 경우는 일반 함수처럼 동작
ex) int x[Add(n1,n1)];
위에것은 실행시간에 하는 거니깐 컴파일 타임 상수가 아니니깐 error발생
int n3 = Add(n1,n2);처럼 사용하는건 일반함수처럼 동작해 문제가 없다.

3.함수 호출 구문을 배열의 크기나 템플릿 인자등 컴파일 시간 상수가 필요한 곳에 사용할 수 잇다.

4.라이브러리 설계에서 많이 사용하는 문법

5.constexpr int Add(int a, int b)
{
    이 함수안에서는 컴파일 시간에 할 수 있는 일만 수행해야한다
    실행시간에 필요한 작업을 여기서 하면 에러가 발생
    cppreference.com에서 할수없는 예제가 나온다.
}

constexpr는 손해볼게 없네????
*/