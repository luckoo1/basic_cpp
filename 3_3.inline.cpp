int Add1(int a, int b)
{
    return a + b;
}

inline int Add2(int a, int b)
{
    return a + b;
}

int main()
{
    int a = 1;
    int b = 2;
    int n1 = Add1(a, b);
    //위에 코드가 호출되면
    //Add1이 이동한다.
    int n2 = Add2(a, b);
    //Add2의 기계어 코드를 가지고 있다가
    //위의 순간에 가져다 놓는다.
    //장점 : 속도가 빠르다.
    int n3 = Add2(a, b);
    //단점 : 실행파일 크기가 커질수 있다.
    //위와같이 두번 사용하면
    //기계어 코드가 2번 놓이게 된다.
}

/*
정리
함수 호출시 실제 함수로 이동하지 않고 함수의 기계어 코드를 치환한다.
장점 : 빠르다
단점 : 치환되는 함수의 크기가 큰 경우 목적 코드가 커질 수 있다.
정확하게 확인하고 싶으면 어셈블리 코드보면된다
int n1 = Add1(a, b); 이순간에는 call이라는 코드가 나오는데
int n3 = Add2(a, b); 이순간에는 안나온다
어셈블리 소스 만드는법
g++ 소스이름.cpp -S -02
소스이름.s로 나온다.
-02는 최적화해달라는 명령어다

한줄짜리 함수정도는 inline이 더 좋을수 있다
호출하는거보다 치환된부분이 더 짧아서 그렇다.
만약 inline함수부분이 길어지면 inline의 코드가 커진다.
*/